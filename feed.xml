<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zeropio.ninja//</id><title>Zeropio's Dojo</title><subtitle>Diving into low level.</subtitle> <updated>2023-05-30T13:30:26+02:00</updated> <author> <name>zeropio</name> <uri>https://zeropio.ninja//</uri> </author><link rel="self" type="application/atom+xml" href="https://zeropio.ninja//feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://zeropio.ninja//"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 zeropio </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Reversing Rust 1 | Research</title><link href="https://zeropio.ninja//research/rustversing/part-1" rel="alternate" type="text/html" title="Reversing Rust 1 | Research" /><published>2023-05-20T00:00:00+02:00</published> <updated>2023-05-20T00:00:00+02:00</updated> <id>https://zeropio.ninja//research/rustversing/part-1</id> <content src="https://zeropio.ninja//research/rustversing/part-1" /> <author> <name>x4sh3s</name> </author> <category term="research" /> <category term="rustversing" /> <summary> Why? you may ask. I had asked myself the same question, but a friend provided me with a different perspective. In the early days of reversing, back in the 80s (I guess?), people didn’t know how to reverse a simple C binary like we do today. They started by examining plain disassembly, gradually progressing to where we are now. But what about Rust? It is often said that reversing Rust is far fro... </summary> </entry> <entry><title>The Shellcode Blacksmith | Sensei</title><link href="https://zeropio.ninja//sensei/shellcode-blacksmith" rel="alternate" type="text/html" title="The Shellcode Blacksmith | Sensei" /><published>2023-05-09T00:00:00+02:00</published> <updated>2023-05-30T13:29:01+02:00</updated> <id>https://zeropio.ninja//sensei/shellcode-blacksmith</id> <content src="https://zeropio.ninja//sensei/shellcode-blacksmith" /> <author> <name>x4sh3s</name> </author> <category term="Sensei" /> <category term="malware" /> <summary> Welcome to the first post of my series on various low level topics. In this series, I will focus as deeply as possible into more advanced topics, rather than simply explaining common vulnerabilities like SQL injection or XSS. Instead, I’ll be focusing on subjects that I find more interesting. Since this is my first post of this kind, I’d like to emphasize an important point. I know that many ... </summary> </entry> <entry><title>OSDev | Chapter 4 | Memory Management</title><link href="https://zeropio.ninja//lowlevel/osdev/chapter-4" rel="alternate" type="text/html" title="OSDev | Chapter 4 | Memory Management" /><published>2023-04-27T00:00:00+02:00</published> <updated>2023-05-09T11:14:07+02:00</updated> <id>https://zeropio.ninja//lowlevel/osdev/chapter-4</id> <content src="https://zeropio.ninja//lowlevel/osdev/chapter-4" /> <author> <name>x4sh3s</name> </author> <category term="LowLevel" /> <category term="OSDev" /> <summary> Introduction In this part, we will implement two key memory management features: paging, which enables mapping physical memory to virtual memory, and heap allocation, which provides dynamic memory allocation for processes. Paging Memory access for each program should be independent from others. One process should not be able to access the memory of another process. Segmentation and pagin... </summary> </entry> <entry><title>OSDev | Chapter 3 | Interrupts</title><link href="https://zeropio.ninja//lowlevel/osdev/chapter-3" rel="alternate" type="text/html" title="OSDev | Chapter 3 | Interrupts" /><published>2023-04-26T00:00:00+02:00</published> <updated>2023-05-09T11:14:07+02:00</updated> <id>https://zeropio.ninja//lowlevel/osdev/chapter-3</id> <content src="https://zeropio.ninja//lowlevel/osdev/chapter-3" /> <author> <name>x4sh3s</name> </author> <category term="LowLevel" /> <category term="OSDev" /> <summary> Introduction To create a functional OS, it is essential to handle errors such as division by zero, attempts to access non-existent memory addresses, and other potential issues. One approach to handling errors is to create an interrupt descriptor table1. Additionally, using different structs can also provide a better understanding of the system’s overall structure and organization. CPU Exc... </summary> </entry> <entry><title>OSDev | Chapter 2 | Rust Kernel</title><link href="https://zeropio.ninja//lowlevel/osdev/chapter-2" rel="alternate" type="text/html" title="OSDev | Chapter 2 | Rust Kernel" /><published>2023-04-17T00:00:00+02:00</published> <updated>2023-05-09T11:14:07+02:00</updated> <id>https://zeropio.ninja//lowlevel/osdev/chapter-2</id> <content src="https://zeropio.ninja//lowlevel/osdev/chapter-2" /> <author> <name>x4sh3s</name> </author> <category term="LowLevel" /> <category term="OSDev" /> <summary> Introduction Now that we have a freestanding Rust binary, the next step is to create the kernel. We will create a 64-bit kernel for the x86 architecture. As we saw in the first chapter, we will begin by developing a bootable file. The Boot As explained in Chapter 0, almost all modern machines have a BIOS. When a computer is started, the BIOS runs by itself and initializes all the hardwar... </summary> </entry> </feed>
